// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: bookings.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const cancelBooking = `-- name: CancelBooking :one
UPDATE booking
SET status = 'cancelled'
WHERE id = $1
RETURNING id, requester_id, manager_id, item_id, group_id, availability_id, pick_up_date, pick_up_location, return_date, return_location, status, confirmed_at, confirmed_by, created_at
`

func (q *Queries) CancelBooking(ctx context.Context, id uuid.UUID) (Booking, error) {
	row := q.db.QueryRow(ctx, cancelBooking, id)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.RequesterID,
		&i.ManagerID,
		&i.ItemID,
		&i.GroupID,
		&i.AvailabilityID,
		&i.PickUpDate,
		&i.PickUpLocation,
		&i.ReturnDate,
		&i.ReturnLocation,
		&i.Status,
		&i.ConfirmedAt,
		&i.ConfirmedBy,
		&i.CreatedAt,
	)
	return i, err
}

const confirmBooking = `-- name: ConfirmBooking :one
UPDATE booking
SET status = 'confirmed',
    confirmed_at = NOW(),
    confirmed_by = $2
WHERE id = $1
RETURNING id, requester_id, manager_id, item_id, group_id, availability_id, pick_up_date, pick_up_location, return_date, return_location, status, confirmed_at, confirmed_by, created_at
`

type ConfirmBookingParams struct {
	ID          uuid.UUID  `json:"id"`
	ConfirmedBy *uuid.UUID `json:"confirmed_by"`
}

func (q *Queries) ConfirmBooking(ctx context.Context, arg ConfirmBookingParams) (Booking, error) {
	row := q.db.QueryRow(ctx, confirmBooking, arg.ID, arg.ConfirmedBy)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.RequesterID,
		&i.ManagerID,
		&i.ItemID,
		&i.GroupID,
		&i.AvailabilityID,
		&i.PickUpDate,
		&i.PickUpLocation,
		&i.ReturnDate,
		&i.ReturnLocation,
		&i.Status,
		&i.ConfirmedAt,
		&i.ConfirmedBy,
		&i.CreatedAt,
	)
	return i, err
}

const createBooking = `-- name: CreateBooking :one
INSERT INTO booking (
    id, requester_id, manager_id, item_id, group_id, availability_id,
    pick_up_date, pick_up_location, return_date, return_location, status
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, requester_id, manager_id, item_id, group_id, availability_id, pick_up_date, pick_up_location, return_date, return_location, status, confirmed_at, confirmed_by, created_at
`

type CreateBookingParams struct {
	ID             uuid.UUID        `json:"id"`
	RequesterID    *uuid.UUID       `json:"requester_id"`
	ManagerID      *uuid.UUID       `json:"manager_id"`
	ItemID         *uuid.UUID       `json:"item_id"`
	GroupID        *uuid.UUID       `json:"group_id"`
	AvailabilityID *uuid.UUID       `json:"availability_id"`
	PickUpDate     pgtype.Timestamp `json:"pick_up_date"`
	PickUpLocation string           `json:"pick_up_location"`
	ReturnDate     pgtype.Timestamp `json:"return_date"`
	ReturnLocation string           `json:"return_location"`
	Status         RequestStatus    `json:"status"`
}

func (q *Queries) CreateBooking(ctx context.Context, arg CreateBookingParams) (Booking, error) {
	row := q.db.QueryRow(ctx, createBooking,
		arg.ID,
		arg.RequesterID,
		arg.ManagerID,
		arg.ItemID,
		arg.GroupID,
		arg.AvailabilityID,
		arg.PickUpDate,
		arg.PickUpLocation,
		arg.ReturnDate,
		arg.ReturnLocation,
		arg.Status,
	)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.RequesterID,
		&i.ManagerID,
		&i.ItemID,
		&i.GroupID,
		&i.AvailabilityID,
		&i.PickUpDate,
		&i.PickUpLocation,
		&i.ReturnDate,
		&i.ReturnLocation,
		&i.Status,
		&i.ConfirmedAt,
		&i.ConfirmedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getBookingByID = `-- name: GetBookingByID :one
SELECT
    b.id, b.requester_id, b.manager_id, b.item_id, b.group_id, b.availability_id, b.pick_up_date, b.pick_up_location, b.return_date, b.return_location, b.status, b.confirmed_at, b.confirmed_by, b.created_at,
    requester.email as requester_email,
    manager.email as manager_email,
    i.name as item_name,
    i.type as item_type,
    ua.date as availability_date,
    g.name as group_name,
    ts.start_time,
    ts.end_time
FROM booking b
JOIN users requester ON b.requester_id = requester.id
LEFT JOIN users manager ON b.manager_id = manager.id
JOIN items i ON b.item_id = i.id
JOIN groups g ON b.group_id = g.id
JOIN user_availability ua ON b.availability_id = ua.id
JOIN time_slots ts ON ua.time_slot_id = ts.id
WHERE b.id = $1
`

type GetBookingByIDRow struct {
	ID               uuid.UUID        `json:"id"`
	RequesterID      *uuid.UUID       `json:"requester_id"`
	ManagerID        *uuid.UUID       `json:"manager_id"`
	ItemID           *uuid.UUID       `json:"item_id"`
	GroupID          *uuid.UUID       `json:"group_id"`
	AvailabilityID   *uuid.UUID       `json:"availability_id"`
	PickUpDate       pgtype.Timestamp `json:"pick_up_date"`
	PickUpLocation   string           `json:"pick_up_location"`
	ReturnDate       pgtype.Timestamp `json:"return_date"`
	ReturnLocation   string           `json:"return_location"`
	Status           RequestStatus    `json:"status"`
	ConfirmedAt      pgtype.Timestamp `json:"confirmed_at"`
	ConfirmedBy      *uuid.UUID       `json:"confirmed_by"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	RequesterEmail   string           `json:"requester_email"`
	ManagerEmail     pgtype.Text      `json:"manager_email"`
	ItemName         string           `json:"item_name"`
	ItemType         ItemType         `json:"item_type"`
	AvailabilityDate pgtype.Date      `json:"availability_date"`
	GroupName        string           `json:"group_name"`
	StartTime        pgtype.Time      `json:"start_time"`
	EndTime          pgtype.Time      `json:"end_time"`
}

func (q *Queries) GetBookingByID(ctx context.Context, id uuid.UUID) (GetBookingByIDRow, error) {
	row := q.db.QueryRow(ctx, getBookingByID, id)
	var i GetBookingByIDRow
	err := row.Scan(
		&i.ID,
		&i.RequesterID,
		&i.ManagerID,
		&i.ItemID,
		&i.GroupID,
		&i.AvailabilityID,
		&i.PickUpDate,
		&i.PickUpLocation,
		&i.ReturnDate,
		&i.ReturnLocation,
		&i.Status,
		&i.ConfirmedAt,
		&i.ConfirmedBy,
		&i.CreatedAt,
		&i.RequesterEmail,
		&i.ManagerEmail,
		&i.ItemName,
		&i.ItemType,
		&i.AvailabilityDate,
		&i.GroupName,
		&i.StartTime,
		&i.EndTime,
	)
	return i, err
}

const getBookingByIDForUpdate = `-- name: GetBookingByIDForUpdate :one
SELECT id, requester_id, manager_id, item_id, group_id, availability_id, pick_up_date, pick_up_location, return_date, return_location, status, confirmed_at, confirmed_by, created_at FROM booking WHERE id = $1 FOR UPDATE
`

func (q *Queries) GetBookingByIDForUpdate(ctx context.Context, id uuid.UUID) (Booking, error) {
	row := q.db.QueryRow(ctx, getBookingByIDForUpdate, id)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.RequesterID,
		&i.ManagerID,
		&i.ItemID,
		&i.GroupID,
		&i.AvailabilityID,
		&i.PickUpDate,
		&i.PickUpLocation,
		&i.ReturnDate,
		&i.ReturnLocation,
		&i.Status,
		&i.ConfirmedAt,
		&i.ConfirmedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getExpiredBookings = `-- name: GetExpiredBookings :many
SELECT id FROM booking
WHERE status = 'pending_confirmation'
  AND created_at < NOW() - INTERVAL '48 hours'
`

func (q *Queries) GetExpiredBookings(ctx context.Context) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, getExpiredBookings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []uuid.UUID{}
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBookings = `-- name: ListBookings :many
SELECT
    b.id, b.requester_id, b.manager_id, b.item_id, b.group_id, b.availability_id, b.pick_up_date, b.pick_up_location, b.return_date, b.return_location, b.status, b.confirmed_at, b.confirmed_by, b.created_at,
    requester.email as requester_email,
    manager.email as manager_email,
    i.name as item_name,
    ua.date as availability_date,
    g.name as group_name
FROM booking b
JOIN users requester ON b.requester_id = requester.id
LEFT JOIN users manager ON b.manager_id = manager.id
JOIN items i ON b.item_id = i.id
JOIN groups g ON b.group_id = g.id
JOIN user_availability ua ON b.availability_id = ua.id
WHERE ($1::request_status IS NULL OR b.status = $1)
  AND ($2::UUID IS NULL OR b.group_id = $2)
  AND ($3::DATE IS NULL OR ua.date >= $3)
  AND ($4::DATE IS NULL OR ua.date <= $4)
ORDER BY ua.date, b.pick_up_date
`

type ListBookingsParams struct {
	Status   NullRequestStatus `json:"status"`
	GroupID  *uuid.UUID        `json:"group_id"`
	FromDate pgtype.Date       `json:"from_date"`
	ToDate   pgtype.Date       `json:"to_date"`
}

type ListBookingsRow struct {
	ID               uuid.UUID        `json:"id"`
	RequesterID      *uuid.UUID       `json:"requester_id"`
	ManagerID        *uuid.UUID       `json:"manager_id"`
	ItemID           *uuid.UUID       `json:"item_id"`
	GroupID          *uuid.UUID       `json:"group_id"`
	AvailabilityID   *uuid.UUID       `json:"availability_id"`
	PickUpDate       pgtype.Timestamp `json:"pick_up_date"`
	PickUpLocation   string           `json:"pick_up_location"`
	ReturnDate       pgtype.Timestamp `json:"return_date"`
	ReturnLocation   string           `json:"return_location"`
	Status           RequestStatus    `json:"status"`
	ConfirmedAt      pgtype.Timestamp `json:"confirmed_at"`
	ConfirmedBy      *uuid.UUID       `json:"confirmed_by"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	RequesterEmail   string           `json:"requester_email"`
	ManagerEmail     pgtype.Text      `json:"manager_email"`
	ItemName         string           `json:"item_name"`
	AvailabilityDate pgtype.Date      `json:"availability_date"`
	GroupName        string           `json:"group_name"`
}

func (q *Queries) ListBookings(ctx context.Context, arg ListBookingsParams) ([]ListBookingsRow, error) {
	rows, err := q.db.Query(ctx, listBookings,
		arg.Status,
		arg.GroupID,
		arg.FromDate,
		arg.ToDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListBookingsRow{}
	for rows.Next() {
		var i ListBookingsRow
		if err := rows.Scan(
			&i.ID,
			&i.RequesterID,
			&i.ManagerID,
			&i.ItemID,
			&i.GroupID,
			&i.AvailabilityID,
			&i.PickUpDate,
			&i.PickUpLocation,
			&i.ReturnDate,
			&i.ReturnLocation,
			&i.Status,
			&i.ConfirmedAt,
			&i.ConfirmedBy,
			&i.CreatedAt,
			&i.RequesterEmail,
			&i.ManagerEmail,
			&i.ItemName,
			&i.AvailabilityDate,
			&i.GroupName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBookingsByUser = `-- name: ListBookingsByUser :many
SELECT
    b.id, b.requester_id, b.manager_id, b.item_id, b.group_id, b.availability_id, b.pick_up_date, b.pick_up_location, b.return_date, b.return_location, b.status, b.confirmed_at, b.confirmed_by, b.created_at,
    manager.email as manager_email,
    i.name as item_name,
    ua.date as availability_date,
    ts.start_time,
    ts.end_time
FROM booking b
LEFT JOIN users manager ON b.manager_id = manager.id
JOIN items i ON b.item_id = i.id
JOIN user_availability ua ON b.availability_id = ua.id
JOIN time_slots ts ON ua.time_slot_id = ts.id
WHERE b.requester_id = $1
  AND ($2::request_status IS NULL OR b.status = $2)
ORDER BY ua.date DESC
`

type ListBookingsByUserParams struct {
	RequesterID *uuid.UUID        `json:"requester_id"`
	Status      NullRequestStatus `json:"status"`
}

type ListBookingsByUserRow struct {
	ID               uuid.UUID        `json:"id"`
	RequesterID      *uuid.UUID       `json:"requester_id"`
	ManagerID        *uuid.UUID       `json:"manager_id"`
	ItemID           *uuid.UUID       `json:"item_id"`
	GroupID          *uuid.UUID       `json:"group_id"`
	AvailabilityID   *uuid.UUID       `json:"availability_id"`
	PickUpDate       pgtype.Timestamp `json:"pick_up_date"`
	PickUpLocation   string           `json:"pick_up_location"`
	ReturnDate       pgtype.Timestamp `json:"return_date"`
	ReturnLocation   string           `json:"return_location"`
	Status           RequestStatus    `json:"status"`
	ConfirmedAt      pgtype.Timestamp `json:"confirmed_at"`
	ConfirmedBy      *uuid.UUID       `json:"confirmed_by"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	ManagerEmail     pgtype.Text      `json:"manager_email"`
	ItemName         string           `json:"item_name"`
	AvailabilityDate pgtype.Date      `json:"availability_date"`
	StartTime        pgtype.Time      `json:"start_time"`
	EndTime          pgtype.Time      `json:"end_time"`
}

func (q *Queries) ListBookingsByUser(ctx context.Context, arg ListBookingsByUserParams) ([]ListBookingsByUserRow, error) {
	rows, err := q.db.Query(ctx, listBookingsByUser, arg.RequesterID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListBookingsByUserRow{}
	for rows.Next() {
		var i ListBookingsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.RequesterID,
			&i.ManagerID,
			&i.ItemID,
			&i.GroupID,
			&i.AvailabilityID,
			&i.PickUpDate,
			&i.PickUpLocation,
			&i.ReturnDate,
			&i.ReturnLocation,
			&i.Status,
			&i.ConfirmedAt,
			&i.ConfirmedBy,
			&i.CreatedAt,
			&i.ManagerEmail,
			&i.ItemName,
			&i.AvailabilityDate,
			&i.StartTime,
			&i.EndTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingConfirmation = `-- name: ListPendingConfirmation :many
SELECT
    b.id, b.requester_id, b.manager_id, b.item_id, b.group_id, b.availability_id, b.pick_up_date, b.pick_up_location, b.return_date, b.return_location, b.status, b.confirmed_at, b.confirmed_by, b.created_at,
    requester.email as requester_email,
    i.name as item_name,
    ua.date as availability_date,
    g.name as group_name,
    ts.start_time
FROM booking b
JOIN users requester ON b.requester_id = requester.id
JOIN items i ON b.item_id = i.id
JOIN groups g ON b.group_id = g.id
JOIN user_availability ua ON b.availability_id = ua.id
JOIN time_slots ts ON ua.time_slot_id = ts.id
WHERE b.status = 'pending_confirmation'
  AND ($1::UUID IS NULL OR b.group_id = $1)
ORDER BY ua.date, ts.start_time
`

type ListPendingConfirmationRow struct {
	ID               uuid.UUID        `json:"id"`
	RequesterID      *uuid.UUID       `json:"requester_id"`
	ManagerID        *uuid.UUID       `json:"manager_id"`
	ItemID           *uuid.UUID       `json:"item_id"`
	GroupID          *uuid.UUID       `json:"group_id"`
	AvailabilityID   *uuid.UUID       `json:"availability_id"`
	PickUpDate       pgtype.Timestamp `json:"pick_up_date"`
	PickUpLocation   string           `json:"pick_up_location"`
	ReturnDate       pgtype.Timestamp `json:"return_date"`
	ReturnLocation   string           `json:"return_location"`
	Status           RequestStatus    `json:"status"`
	ConfirmedAt      pgtype.Timestamp `json:"confirmed_at"`
	ConfirmedBy      *uuid.UUID       `json:"confirmed_by"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	RequesterEmail   string           `json:"requester_email"`
	ItemName         string           `json:"item_name"`
	AvailabilityDate pgtype.Date      `json:"availability_date"`
	GroupName        string           `json:"group_name"`
	StartTime        pgtype.Time      `json:"start_time"`
}

func (q *Queries) ListPendingConfirmation(ctx context.Context, groupID *uuid.UUID) ([]ListPendingConfirmationRow, error) {
	rows, err := q.db.Query(ctx, listPendingConfirmation, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPendingConfirmationRow{}
	for rows.Next() {
		var i ListPendingConfirmationRow
		if err := rows.Scan(
			&i.ID,
			&i.RequesterID,
			&i.ManagerID,
			&i.ItemID,
			&i.GroupID,
			&i.AvailabilityID,
			&i.PickUpDate,
			&i.PickUpLocation,
			&i.ReturnDate,
			&i.ReturnLocation,
			&i.Status,
			&i.ConfirmedAt,
			&i.ConfirmedBy,
			&i.CreatedAt,
			&i.RequesterEmail,
			&i.ItemName,
			&i.AvailabilityDate,
			&i.GroupName,
			&i.StartTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
