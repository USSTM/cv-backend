// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: checkout.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const decrementStockForLowItem = `-- name: DecrementStockForLowItem :exec
UPDATE items
SET stock = stock - $2
WHERE id = $1
  AND type = 'low'
  AND stock >= $2
`

type DecrementStockForLowItemParams struct {
	ID    uuid.UUID `json:"id"`
	Stock int32     `json:"stock"`
}

func (q *Queries) DecrementStockForLowItem(ctx context.Context, arg DecrementStockForLowItemParams) error {
	_, err := q.db.Exec(ctx, decrementStockForLowItem, arg.ID, arg.Stock)
	return err
}

const getCartItemsForCheckout = `-- name: GetCartItemsForCheckout :many
SELECT c.group_id, c.user_id, c.item_id, c.quantity,
       i.type, i.stock, i.name
FROM cart c
JOIN items i ON c.item_id = i.id
WHERE c.group_id = $1 AND c.user_id = $2
FOR UPDATE OF i
`

type GetCartItemsForCheckoutParams struct {
	GroupID uuid.UUID `json:"group_id"`
	UserID  uuid.UUID `json:"user_id"`
}

type GetCartItemsForCheckoutRow struct {
	GroupID  uuid.UUID `json:"group_id"`
	UserID   uuid.UUID `json:"user_id"`
	ItemID   uuid.UUID `json:"item_id"`
	Quantity int32     `json:"quantity"`
	Type     ItemType  `json:"type"`
	Stock    int32     `json:"stock"`
	Name     string    `json:"name"`
}

func (q *Queries) GetCartItemsForCheckout(ctx context.Context, arg GetCartItemsForCheckoutParams) ([]GetCartItemsForCheckoutRow, error) {
	rows, err := q.db.Query(ctx, getCartItemsForCheckout, arg.GroupID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCartItemsForCheckoutRow{}
	for rows.Next() {
		var i GetCartItemsForCheckoutRow
		if err := rows.Scan(
			&i.GroupID,
			&i.UserID,
			&i.ItemID,
			&i.Quantity,
			&i.Type,
			&i.Stock,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordItemTaking = `-- name: RecordItemTaking :one
INSERT INTO item_takings (user_id, group_id, item_id, quantity)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, group_id, item_id, quantity, taken_at
`

type RecordItemTakingParams struct {
	UserID   uuid.UUID `json:"user_id"`
	GroupID  uuid.UUID `json:"group_id"`
	ItemID   uuid.UUID `json:"item_id"`
	Quantity int32     `json:"quantity"`
}

func (q *Queries) RecordItemTaking(ctx context.Context, arg RecordItemTakingParams) (ItemTaking, error) {
	row := q.db.QueryRow(ctx, recordItemTaking,
		arg.UserID,
		arg.GroupID,
		arg.ItemID,
		arg.Quantity,
	)
	var i ItemTaking
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.ItemID,
		&i.Quantity,
		&i.TakenAt,
	)
	return i, err
}
