// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: notifications.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type BulkCreateNotificationsParams struct {
	UserID           uuid.UUID            `json:"user_id"`
	Type             NotificationType     `json:"type"`
	Title            string               `json:"title"`
	Message          string               `json:"message"`
	Priority         NotificationPriority `json:"priority"`
	ExpiresAt        pgtype.Timestamp     `json:"expires_at"`
	RelatedBookingID *uuid.UUID           `json:"related_booking_id"`
	RelatedRequestID *uuid.UUID           `json:"related_request_id"`
	RelatedItemID    *uuid.UUID           `json:"related_item_id"`
	RelatedUserID    *uuid.UUID           `json:"related_user_id"`
	Metadata         []byte               `json:"metadata"`
}

const countNotificationsByType = `-- name: CountNotificationsByType :one
SELECT COUNT(*) FROM notifications
WHERE user_id = $1 AND type = $2 AND read_at IS NULL
`

type CountNotificationsByTypeParams struct {
	UserID uuid.UUID        `json:"user_id"`
	Type   NotificationType `json:"type"`
}

func (q *Queries) CountNotificationsByType(ctx context.Context, arg CountNotificationsByTypeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countNotificationsByType, arg.UserID, arg.Type)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUnreadNotifications = `-- name: CountUnreadNotifications :one
SELECT COUNT(*) FROM notifications
WHERE user_id = $1 AND read_at IS NULL
`

func (q *Queries) CountUnreadNotifications(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUnreadNotifications, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createNotification = `-- name: CreateNotification :one
INSERT INTO notifications (
    user_id, type, title, message, priority, expires_at,
    related_booking_id, related_request_id, related_item_id, related_user_id, metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, user_id, type, title, message, priority, read_at, created_at, expires_at, related_booking_id, related_request_id, related_item_id, related_user_id, metadata
`

type CreateNotificationParams struct {
	UserID           uuid.UUID            `json:"user_id"`
	Type             NotificationType     `json:"type"`
	Title            string               `json:"title"`
	Message          string               `json:"message"`
	Priority         NotificationPriority `json:"priority"`
	ExpiresAt        pgtype.Timestamp     `json:"expires_at"`
	RelatedBookingID *uuid.UUID           `json:"related_booking_id"`
	RelatedRequestID *uuid.UUID           `json:"related_request_id"`
	RelatedItemID    *uuid.UUID           `json:"related_item_id"`
	RelatedUserID    *uuid.UUID           `json:"related_user_id"`
	Metadata         []byte               `json:"metadata"`
}

func (q *Queries) CreateNotification(ctx context.Context, arg CreateNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, createNotification,
		arg.UserID,
		arg.Type,
		arg.Title,
		arg.Message,
		arg.Priority,
		arg.ExpiresAt,
		arg.RelatedBookingID,
		arg.RelatedRequestID,
		arg.RelatedItemID,
		arg.RelatedUserID,
		arg.Metadata,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Title,
		&i.Message,
		&i.Priority,
		&i.ReadAt,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.RelatedBookingID,
		&i.RelatedRequestID,
		&i.RelatedItemID,
		&i.RelatedUserID,
		&i.Metadata,
	)
	return i, err
}

const deleteExpiredNotifications = `-- name: DeleteExpiredNotifications :exec
DELETE FROM notifications
WHERE expires_at IS NOT NULL AND expires_at < NOW()
`

func (q *Queries) DeleteExpiredNotifications(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredNotifications)
	return err
}

const deleteNotification = `-- name: DeleteNotification :exec
DELETE FROM notifications
WHERE id = $1 AND user_id = $2
`

type DeleteNotificationParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteNotification(ctx context.Context, arg DeleteNotificationParams) error {
	_, err := q.db.Exec(ctx, deleteNotification, arg.ID, arg.UserID)
	return err
}

const deleteReadNotifications = `-- name: DeleteReadNotifications :exec
DELETE FROM notifications
WHERE user_id = $1 AND read_at IS NOT NULL
`

func (q *Queries) DeleteReadNotifications(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteReadNotifications, userID)
	return err
}

const getNotification = `-- name: GetNotification :one
SELECT id, user_id, type, title, message, priority, read_at, created_at, expires_at, related_booking_id, related_request_id, related_item_id, related_user_id, metadata FROM notifications
WHERE id = $1
`

func (q *Queries) GetNotification(ctx context.Context, id uuid.UUID) (Notification, error) {
	row := q.db.QueryRow(ctx, getNotification, id)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Title,
		&i.Message,
		&i.Priority,
		&i.ReadAt,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.RelatedBookingID,
		&i.RelatedRequestID,
		&i.RelatedItemID,
		&i.RelatedUserID,
		&i.Metadata,
	)
	return i, err
}

const getNotificationStats = `-- name: GetNotificationStats :one
SELECT
    COUNT(*) as total_notifications,
    COUNT(*) FILTER (WHERE read_at IS NULL) as unread_count,
    COUNT(*) FILTER (WHERE priority = 'high') as high_priority_count,
    COUNT(*) FILTER (WHERE priority = 'high' AND read_at IS NULL) as unread_high_priority_count
FROM notifications
WHERE user_id = $1
`

type GetNotificationStatsRow struct {
	TotalNotifications      int64 `json:"total_notifications"`
	UnreadCount             int64 `json:"unread_count"`
	HighPriorityCount       int64 `json:"high_priority_count"`
	UnreadHighPriorityCount int64 `json:"unread_high_priority_count"`
}

func (q *Queries) GetNotificationStats(ctx context.Context, userID uuid.UUID) (GetNotificationStatsRow, error) {
	row := q.db.QueryRow(ctx, getNotificationStats, userID)
	var i GetNotificationStatsRow
	err := row.Scan(
		&i.TotalNotifications,
		&i.UnreadCount,
		&i.HighPriorityCount,
		&i.UnreadHighPriorityCount,
	)
	return i, err
}

const getNotificationsByPriority = `-- name: GetNotificationsByPriority :many
SELECT id, user_id, type, title, message, priority, read_at, created_at, expires_at, related_booking_id, related_request_id, related_item_id, related_user_id, metadata FROM notifications
WHERE user_id = $1 AND priority = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetNotificationsByPriorityParams struct {
	UserID   uuid.UUID            `json:"user_id"`
	Priority NotificationPriority `json:"priority"`
	Limit    int64                `json:"limit"`
	Offset   int64                `json:"offset"`
}

func (q *Queries) GetNotificationsByPriority(ctx context.Context, arg GetNotificationsByPriorityParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getNotificationsByPriority,
		arg.UserID,
		arg.Priority,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Notification{}
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Type,
			&i.Title,
			&i.Message,
			&i.Priority,
			&i.ReadAt,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.RelatedBookingID,
			&i.RelatedRequestID,
			&i.RelatedItemID,
			&i.RelatedUserID,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotificationsByType = `-- name: GetNotificationsByType :many
SELECT id, user_id, type, title, message, priority, read_at, created_at, expires_at, related_booking_id, related_request_id, related_item_id, related_user_id, metadata FROM notifications
WHERE user_id = $1 AND type = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetNotificationsByTypeParams struct {
	UserID uuid.UUID        `json:"user_id"`
	Type   NotificationType `json:"type"`
	Limit  int64            `json:"limit"`
	Offset int64            `json:"offset"`
}

func (q *Queries) GetNotificationsByType(ctx context.Context, arg GetNotificationsByTypeParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getNotificationsByType,
		arg.UserID,
		arg.Type,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Notification{}
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Type,
			&i.Title,
			&i.Message,
			&i.Priority,
			&i.ReadAt,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.RelatedBookingID,
			&i.RelatedRequestID,
			&i.RelatedItemID,
			&i.RelatedUserID,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentNotifications = `-- name: GetRecentNotifications :many
SELECT id, user_id, type, title, message, priority, read_at, created_at, expires_at, related_booking_id, related_request_id, related_item_id, related_user_id, metadata FROM notifications
WHERE user_id = $1 AND created_at >= $2
ORDER BY created_at DESC
`

type GetRecentNotificationsParams struct {
	UserID    uuid.UUID        `json:"user_id"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetRecentNotifications(ctx context.Context, arg GetRecentNotificationsParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getRecentNotifications, arg.UserID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Notification{}
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Type,
			&i.Title,
			&i.Message,
			&i.Priority,
			&i.ReadAt,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.RelatedBookingID,
			&i.RelatedRequestID,
			&i.RelatedItemID,
			&i.RelatedUserID,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnreadUserNotifications = `-- name: GetUnreadUserNotifications :many
SELECT id, user_id, type, title, message, priority, read_at, created_at, expires_at, related_booking_id, related_request_id, related_item_id, related_user_id, metadata FROM notifications
WHERE user_id = $1 AND read_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetUnreadUserNotificationsParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int64     `json:"limit"`
	Offset int64     `json:"offset"`
}

func (q *Queries) GetUnreadUserNotifications(ctx context.Context, arg GetUnreadUserNotificationsParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getUnreadUserNotifications, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Notification{}
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Type,
			&i.Title,
			&i.Message,
			&i.Priority,
			&i.ReadAt,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.RelatedBookingID,
			&i.RelatedRequestID,
			&i.RelatedItemID,
			&i.RelatedUserID,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserNotifications = `-- name: GetUserNotifications :many
SELECT id, user_id, type, title, message, priority, read_at, created_at, expires_at, related_booking_id, related_request_id, related_item_id, related_user_id, metadata FROM notifications
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetUserNotificationsParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int64     `json:"limit"`
	Offset int64     `json:"offset"`
}

func (q *Queries) GetUserNotifications(ctx context.Context, arg GetUserNotificationsParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getUserNotifications, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Notification{}
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Type,
			&i.Title,
			&i.Message,
			&i.Priority,
			&i.ReadAt,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.RelatedBookingID,
			&i.RelatedRequestID,
			&i.RelatedItemID,
			&i.RelatedUserID,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAllNotificationsAsRead = `-- name: MarkAllNotificationsAsRead :exec
UPDATE notifications
SET read_at = NOW()
WHERE user_id = $1 AND read_at IS NULL
`

func (q *Queries) MarkAllNotificationsAsRead(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, markAllNotificationsAsRead, userID)
	return err
}

const markNotificationAsRead = `-- name: MarkNotificationAsRead :one
UPDATE notifications
SET read_at = NOW()
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, type, title, message, priority, read_at, created_at, expires_at, related_booking_id, related_request_id, related_item_id, related_user_id, metadata
`

type MarkNotificationAsReadParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) MarkNotificationAsRead(ctx context.Context, arg MarkNotificationAsReadParams) (Notification, error) {
	row := q.db.QueryRow(ctx, markNotificationAsRead, arg.ID, arg.UserID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Title,
		&i.Message,
		&i.Priority,
		&i.ReadAt,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.RelatedBookingID,
		&i.RelatedRequestID,
		&i.RelatedItemID,
		&i.RelatedUserID,
		&i.Metadata,
	)
	return i, err
}

const markNotificationsByTypeAsRead = `-- name: MarkNotificationsByTypeAsRead :exec
UPDATE notifications
SET read_at = NOW()
WHERE user_id = $1 AND type = $2 AND read_at IS NULL
`

type MarkNotificationsByTypeAsReadParams struct {
	UserID uuid.UUID        `json:"user_id"`
	Type   NotificationType `json:"type"`
}

func (q *Queries) MarkNotificationsByTypeAsRead(ctx context.Context, arg MarkNotificationsByTypeAsReadParams) error {
	_, err := q.db.Exec(ctx, markNotificationsByTypeAsRead, arg.UserID, arg.Type)
	return err
}

const updateNotificationMetadata = `-- name: UpdateNotificationMetadata :one
UPDATE notifications
SET metadata = $3
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, type, title, message, priority, read_at, created_at, expires_at, related_booking_id, related_request_id, related_item_id, related_user_id, metadata
`

type UpdateNotificationMetadataParams struct {
	ID       uuid.UUID `json:"id"`
	UserID   uuid.UUID `json:"user_id"`
	Metadata []byte    `json:"metadata"`
}

func (q *Queries) UpdateNotificationMetadata(ctx context.Context, arg UpdateNotificationMetadataParams) (Notification, error) {
	row := q.db.QueryRow(ctx, updateNotificationMetadata, arg.ID, arg.UserID, arg.Metadata)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Title,
		&i.Message,
		&i.Priority,
		&i.ReadAt,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.RelatedBookingID,
		&i.RelatedRequestID,
		&i.RelatedItemID,
		&i.RelatedUserID,
		&i.Metadata,
	)
	return i, err
}
