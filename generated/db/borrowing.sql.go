// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: borrowing.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const borrowItem = `-- name: BorrowItem :one
INSERT INTO borrowings (
    user_id, group_id, item_id, quantity,
    due_date, before_condition, before_condition_url
)
SELECT $1, $2, i.id, $4, $5, $6, $7
FROM items i
WHERE i.id = $3
  AND i.type IN ('medium', 'high')
  AND i.stock >= $4
RETURNING id, user_id, group_id, item_id, quantity,
    borrowed_at, due_date, returned_at,
    before_condition, before_condition_url,
    after_condition, after_condition_url
`

type BorrowItemParams struct {
	UserID             *uuid.UUID       `json:"user_id"`
	GroupID            *uuid.UUID       `json:"group_id"`
	ID                 uuid.UUID        `json:"id"`
	Quantity           int32            `json:"quantity"`
	DueDate            pgtype.Timestamp `json:"due_date"`
	BeforeCondition    Condition        `json:"before_condition"`
	BeforeConditionUrl string           `json:"before_condition_url"`
}

// this function creates a new borrowing record for a user borrowing an item
func (q *Queries) BorrowItem(ctx context.Context, arg BorrowItemParams) (Borrowing, error) {
	row := q.db.QueryRow(ctx, borrowItem,
		arg.UserID,
		arg.GroupID,
		arg.ID,
		arg.Quantity,
		arg.DueDate,
		arg.BeforeCondition,
		arg.BeforeConditionUrl,
	)
	var i Borrowing
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.ItemID,
		&i.Quantity,
		&i.BorrowedAt,
		&i.DueDate,
		&i.ReturnedAt,
		&i.BeforeCondition,
		&i.BeforeConditionUrl,
		&i.AfterCondition,
		&i.AfterConditionUrl,
	)
	return i, err
}

const checkBorrowingItemStatus = `-- name: CheckBorrowingItemStatus :one
SELECT NOT EXISTS (
    SELECT 1 FROM borrowings
    WHERE item_id = $1 AND returned_at IS NULL
) AS is_available
`

// this function checks if an item is currently borrowed (i.e., not available) by looking for active borrowings without a return timestamp and returns true if the item is available
func (q *Queries) CheckBorrowingItemStatus(ctx context.Context, itemID *uuid.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, checkBorrowingItemStatus, itemID)
	var is_available bool
	err := row.Scan(&is_available)
	return is_available, err
}

const countActiveBorrowedItemsByUserId = `-- name: CountActiveBorrowedItemsByUserId :one
SELECT COUNT(*) as count FROM borrowings WHERE user_id = $1 AND returned_at IS NULL
`

func (q *Queries) CountActiveBorrowedItemsByUserId(ctx context.Context, userID *uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveBorrowedItemsByUserId, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAllActiveBorrowedItems = `-- name: CountAllActiveBorrowedItems :one
SELECT COUNT(*) as count FROM borrowings WHERE returned_at IS NULL
`

func (q *Queries) CountAllActiveBorrowedItems(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAllActiveBorrowedItems)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAllReturnedItems = `-- name: CountAllReturnedItems :one
SELECT COUNT(*) as count FROM borrowings WHERE returned_at IS NOT NULL
`

func (q *Queries) CountAllReturnedItems(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAllReturnedItems)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countBorrowedItemHistoryByUserId = `-- name: CountBorrowedItemHistoryByUserId :one
SELECT COUNT(*) as count FROM borrowings WHERE user_id = $1
`

func (q *Queries) CountBorrowedItemHistoryByUserId(ctx context.Context, userID *uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countBorrowedItemHistoryByUserId, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countReturnedItemsByUserId = `-- name: CountReturnedItemsByUserId :one
SELECT COUNT(*) as count FROM borrowings WHERE user_id = $1 AND returned_at IS NOT NULL
`

func (q *Queries) CountReturnedItemsByUserId(ctx context.Context, userID *uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countReturnedItemsByUserId, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getActiveBorrowedItemsByUserId = `-- name: GetActiveBorrowedItemsByUserId :many
SELECT id, user_id, group_id, item_id, quantity,
       borrowed_at, due_date, returned_at,
       before_condition, before_condition_url,
       after_condition, after_condition_url
FROM borrowings
WHERE user_id = $1 AND returned_at IS NULL
ORDER BY borrowed_at DESC LIMIT $2 OFFSET $3
`

type GetActiveBorrowedItemsByUserIdParams struct {
	UserID *uuid.UUID `json:"user_id"`
	Limit  int64      `json:"limit"`
	Offset int64      `json:"offset"`
}

func (q *Queries) GetActiveBorrowedItemsByUserId(ctx context.Context, arg GetActiveBorrowedItemsByUserIdParams) ([]Borrowing, error) {
	rows, err := q.db.Query(ctx, getActiveBorrowedItemsByUserId, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Borrowing{}
	for rows.Next() {
		var i Borrowing
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GroupID,
			&i.ItemID,
			&i.Quantity,
			&i.BorrowedAt,
			&i.DueDate,
			&i.ReturnedAt,
			&i.BeforeCondition,
			&i.BeforeConditionUrl,
			&i.AfterCondition,
			&i.AfterConditionUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveBorrowedItemsToBeReturnedByDate = `-- name: GetActiveBorrowedItemsToBeReturnedByDate :many
SELECT id, user_id, group_id, item_id, quantity,
       borrowed_at, due_date, returned_at,
       before_condition, before_condition_url,
       after_condition, after_condition_url
FROM borrowings
WHERE returned_at IS NULL AND due_date <= $1
`

func (q *Queries) GetActiveBorrowedItemsToBeReturnedByDate(ctx context.Context, dueDate pgtype.Timestamp) ([]Borrowing, error) {
	rows, err := q.db.Query(ctx, getActiveBorrowedItemsToBeReturnedByDate, dueDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Borrowing{}
	for rows.Next() {
		var i Borrowing
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GroupID,
			&i.ItemID,
			&i.Quantity,
			&i.BorrowedAt,
			&i.DueDate,
			&i.ReturnedAt,
			&i.BeforeCondition,
			&i.BeforeConditionUrl,
			&i.AfterCondition,
			&i.AfterConditionUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveBorrowingByItemAndUser = `-- name: GetActiveBorrowingByItemAndUser :one
SELECT id, user_id, group_id, item_id, quantity,
       borrowed_at, due_date, returned_at,
       before_condition, before_condition_url,
       after_condition, after_condition_url
FROM borrowings
WHERE item_id = $1 AND user_id = $2 AND returned_at IS NULL
FOR UPDATE
`

type GetActiveBorrowingByItemAndUserParams struct {
	ItemID *uuid.UUID `json:"item_id"`
	UserID *uuid.UUID `json:"user_id"`
}

// this function gets an active borrowing by item_id and user_id, used to validate ownership before return
func (q *Queries) GetActiveBorrowingByItemAndUser(ctx context.Context, arg GetActiveBorrowingByItemAndUserParams) (Borrowing, error) {
	row := q.db.QueryRow(ctx, getActiveBorrowingByItemAndUser, arg.ItemID, arg.UserID)
	var i Borrowing
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.ItemID,
		&i.Quantity,
		&i.BorrowedAt,
		&i.DueDate,
		&i.ReturnedAt,
		&i.BeforeCondition,
		&i.BeforeConditionUrl,
		&i.AfterCondition,
		&i.AfterConditionUrl,
	)
	return i, err
}

const getAllActiveBorrowedItems = `-- name: GetAllActiveBorrowedItems :many
SELECT id, user_id, group_id, item_id, quantity,
       borrowed_at, due_date, returned_at,
       before_condition, before_condition_url,
       after_condition, after_condition_url
FROM borrowings
WHERE returned_at IS NULL
ORDER BY borrowed_at DESC LIMIT $1 OFFSET $2
`

type GetAllActiveBorrowedItemsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) GetAllActiveBorrowedItems(ctx context.Context, arg GetAllActiveBorrowedItemsParams) ([]Borrowing, error) {
	rows, err := q.db.Query(ctx, getAllActiveBorrowedItems, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Borrowing{}
	for rows.Next() {
		var i Borrowing
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GroupID,
			&i.ItemID,
			&i.Quantity,
			&i.BorrowedAt,
			&i.DueDate,
			&i.ReturnedAt,
			&i.BeforeCondition,
			&i.BeforeConditionUrl,
			&i.AfterCondition,
			&i.AfterConditionUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllReturnedItems = `-- name: GetAllReturnedItems :many
SELECT id, user_id, group_id, item_id, quantity,
       borrowed_at, due_date, returned_at,
       before_condition, before_condition_url,
       after_condition, after_condition_url
FROM borrowings
WHERE returned_at IS NOT NULL
ORDER BY returned_at DESC LIMIT $1 OFFSET $2
`

type GetAllReturnedItemsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) GetAllReturnedItems(ctx context.Context, arg GetAllReturnedItemsParams) ([]Borrowing, error) {
	rows, err := q.db.Query(ctx, getAllReturnedItems, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Borrowing{}
	for rows.Next() {
		var i Borrowing
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GroupID,
			&i.ItemID,
			&i.Quantity,
			&i.BorrowedAt,
			&i.DueDate,
			&i.ReturnedAt,
			&i.BeforeCondition,
			&i.BeforeConditionUrl,
			&i.AfterCondition,
			&i.AfterConditionUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBorrowedItemHistoryByUserId = `-- name: GetBorrowedItemHistoryByUserId :many
SELECT id, user_id, group_id, item_id, quantity,
       borrowed_at, due_date, returned_at,
       before_condition, before_condition_url,
       after_condition, after_condition_url
FROM borrowings
WHERE user_id = $1
ORDER BY borrowed_at DESC LIMIT $2 OFFSET $3
`

type GetBorrowedItemHistoryByUserIdParams struct {
	UserID *uuid.UUID `json:"user_id"`
	Limit  int64      `json:"limit"`
	Offset int64      `json:"offset"`
}

func (q *Queries) GetBorrowedItemHistoryByUserId(ctx context.Context, arg GetBorrowedItemHistoryByUserIdParams) ([]Borrowing, error) {
	rows, err := q.db.Query(ctx, getBorrowedItemHistoryByUserId, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Borrowing{}
	for rows.Next() {
		var i Borrowing
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GroupID,
			&i.ItemID,
			&i.Quantity,
			&i.BorrowedAt,
			&i.DueDate,
			&i.ReturnedAt,
			&i.BeforeCondition,
			&i.BeforeConditionUrl,
			&i.AfterCondition,
			&i.AfterConditionUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBorrowingByID = `-- name: GetBorrowingByID :one
SELECT id, user_id, group_id, item_id, quantity,
    borrowed_at, due_date, returned_at,
    before_condition, before_condition_url,
    after_condition, after_condition_url
FROM borrowings WHERE id = $1
`

func (q *Queries) GetBorrowingByID(ctx context.Context, id uuid.UUID) (Borrowing, error) {
	row := q.db.QueryRow(ctx, getBorrowingByID, id)
	var i Borrowing
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.ItemID,
		&i.Quantity,
		&i.BorrowedAt,
		&i.DueDate,
		&i.ReturnedAt,
		&i.BeforeCondition,
		&i.BeforeConditionUrl,
		&i.AfterCondition,
		&i.AfterConditionUrl,
	)
	return i, err
}

const getReturnedItemsByUserId = `-- name: GetReturnedItemsByUserId :many
SELECT id, user_id, group_id, item_id, quantity,
       borrowed_at, due_date, returned_at,
       before_condition, before_condition_url,
       after_condition, after_condition_url
FROM borrowings
WHERE user_id = $1 AND returned_at IS NOT NULL
ORDER BY returned_at DESC LIMIT $2 OFFSET $3
`

type GetReturnedItemsByUserIdParams struct {
	UserID *uuid.UUID `json:"user_id"`
	Limit  int64      `json:"limit"`
	Offset int64      `json:"offset"`
}

func (q *Queries) GetReturnedItemsByUserId(ctx context.Context, arg GetReturnedItemsByUserIdParams) ([]Borrowing, error) {
	rows, err := q.db.Query(ctx, getReturnedItemsByUserId, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Borrowing{}
	for rows.Next() {
		var i Borrowing
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GroupID,
			&i.ItemID,
			&i.Quantity,
			&i.BorrowedAt,
			&i.DueDate,
			&i.ReturnedAt,
			&i.BeforeCondition,
			&i.BeforeConditionUrl,
			&i.AfterCondition,
			&i.AfterConditionUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const returnItem = `-- name: ReturnItem :one
UPDATE borrowings
SET returned_at = NOW(),
    after_condition = $2,
    after_condition_url = $3
WHERE item_id = $1 AND returned_at IS NULL
RETURNING id, user_id, group_id, item_id, quantity,
    borrowed_at, due_date, returned_at,
    before_condition, before_condition_url,
    after_condition, after_condition_url
`

type ReturnItemParams struct {
	ItemID            *uuid.UUID    `json:"item_id"`
	AfterCondition    NullCondition `json:"after_condition"`
	AfterConditionUrl pgtype.Text   `json:"after_condition_url"`
}

// this function records the return of a borrowed item, updating the after condition and return timestamp (basically closing the borrowing record)
// it only works if the item is currently borrowed (i.e., has no return timestamp yet)
// the request is identified by the item_id
func (q *Queries) ReturnItem(ctx context.Context, arg ReturnItemParams) (Borrowing, error) {
	row := q.db.QueryRow(ctx, returnItem, arg.ItemID, arg.AfterCondition, arg.AfterConditionUrl)
	var i Borrowing
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.ItemID,
		&i.Quantity,
		&i.BorrowedAt,
		&i.DueDate,
		&i.ReturnedAt,
		&i.BeforeCondition,
		&i.BeforeConditionUrl,
		&i.AfterCondition,
		&i.AfterConditionUrl,
	)
	return i, err
}
