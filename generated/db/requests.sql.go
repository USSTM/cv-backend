// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: requests.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getAllRequests = `-- name: GetAllRequests :many
SELECT id, user_id, group_id, item_id, quantity, status, requested_at, reviewed_by, reviewed_at, fulfilled_at FROM requests
ORDER BY requested_at DESC
`

func (q *Queries) GetAllRequests(ctx context.Context) ([]Request, error) {
	rows, err := q.db.Query(ctx, getAllRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Request{}
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GroupID,
			&i.ItemID,
			&i.Quantity,
			&i.Status,
			&i.RequestedAt,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.FulfilledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApprovedRequestForUserAndItem = `-- name: GetApprovedRequestForUserAndItem :one
SELECT id, user_id, group_id, item_id, quantity, status, requested_at, reviewed_by, reviewed_at, fulfilled_at FROM requests
WHERE user_id = $1
  AND item_id = $2
  AND status = 'approved'
  AND fulfilled_at IS NULL
ORDER BY reviewed_at DESC
LIMIT 1
`

type GetApprovedRequestForUserAndItemParams struct {
	UserID *uuid.UUID `json:"user_id"`
	ItemID *uuid.UUID `json:"item_id"`
}

func (q *Queries) GetApprovedRequestForUserAndItem(ctx context.Context, arg GetApprovedRequestForUserAndItemParams) (Request, error) {
	row := q.db.QueryRow(ctx, getApprovedRequestForUserAndItem, arg.UserID, arg.ItemID)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.ItemID,
		&i.Quantity,
		&i.Status,
		&i.RequestedAt,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.FulfilledAt,
	)
	return i, err
}

const getPendingRequests = `-- name: GetPendingRequests :many
SELECT id, user_id, group_id, item_id, quantity, status, requested_at, reviewed_by, reviewed_at, fulfilled_at FROM requests
WHERE status = 'pending'
ORDER BY requested_at ASC
`

func (q *Queries) GetPendingRequests(ctx context.Context) ([]Request, error) {
	rows, err := q.db.Query(ctx, getPendingRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Request{}
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GroupID,
			&i.ItemID,
			&i.Quantity,
			&i.Status,
			&i.RequestedAt,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.FulfilledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestById = `-- name: GetRequestById :one
SELECT id, user_id, group_id, item_id, quantity, status, requested_at, reviewed_by, reviewed_at, fulfilled_at FROM requests
WHERE id = $1
`

func (q *Queries) GetRequestById(ctx context.Context, id uuid.UUID) (Request, error) {
	row := q.db.QueryRow(ctx, getRequestById, id)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.ItemID,
		&i.Quantity,
		&i.Status,
		&i.RequestedAt,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.FulfilledAt,
	)
	return i, err
}

const getRequestByIdForUpdate = `-- name: GetRequestByIdForUpdate :one
SELECT id, user_id, group_id, item_id, quantity, status, requested_at, reviewed_by, reviewed_at, fulfilled_at FROM requests
WHERE id = $1
FOR UPDATE
`

func (q *Queries) GetRequestByIdForUpdate(ctx context.Context, id uuid.UUID) (Request, error) {
	row := q.db.QueryRow(ctx, getRequestByIdForUpdate, id)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.ItemID,
		&i.Quantity,
		&i.Status,
		&i.RequestedAt,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.FulfilledAt,
	)
	return i, err
}

const getRequestsByUserId = `-- name: GetRequestsByUserId :many
SELECT id, user_id, group_id, item_id, quantity, status, requested_at, reviewed_by, reviewed_at, fulfilled_at FROM requests
WHERE user_id = $1
ORDER BY requested_at DESC
`

func (q *Queries) GetRequestsByUserId(ctx context.Context, userID *uuid.UUID) ([]Request, error) {
	rows, err := q.db.Query(ctx, getRequestsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Request{}
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GroupID,
			&i.ItemID,
			&i.Quantity,
			&i.Status,
			&i.RequestedAt,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.FulfilledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markRequestAsFulfilled = `-- name: MarkRequestAsFulfilled :exec
UPDATE requests
SET fulfilled_at = NOW()
WHERE id = $1
`

func (q *Queries) MarkRequestAsFulfilled(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, markRequestAsFulfilled, id)
	return err
}

const requestItem = `-- name: RequestItem :one
INSERT INTO requests (
    user_id, group_id, item_id, quantity, status
)
SELECT $1, $2, i.id, $4, 'pending'
FROM items i
WHERE i.id = $3 AND i.type = 'high'
RETURNING id, user_id, group_id, item_id, quantity,
    status, reviewed_at, reviewed_by
`

type RequestItemParams struct {
	UserID   *uuid.UUID `json:"user_id"`
	GroupID  *uuid.UUID `json:"group_id"`
	ID       uuid.UUID  `json:"id"`
	Quantity int32      `json:"quantity"`
}

type RequestItemRow struct {
	ID         uuid.UUID         `json:"id"`
	UserID     *uuid.UUID        `json:"user_id"`
	GroupID    *uuid.UUID        `json:"group_id"`
	ItemID     *uuid.UUID        `json:"item_id"`
	Quantity   int32             `json:"quantity"`
	Status     NullRequestStatus `json:"status"`
	ReviewedAt pgtype.Timestamp  `json:"reviewed_at"`
	ReviewedBy *uuid.UUID        `json:"reviewed_by"`
}

// this function creates a new request in the requests table for a user requesting an item
func (q *Queries) RequestItem(ctx context.Context, arg RequestItemParams) (RequestItemRow, error) {
	row := q.db.QueryRow(ctx, requestItem,
		arg.UserID,
		arg.GroupID,
		arg.ID,
		arg.Quantity,
	)
	var i RequestItemRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.ItemID,
		&i.Quantity,
		&i.Status,
		&i.ReviewedAt,
		&i.ReviewedBy,
	)
	return i, err
}

const reviewRequest = `-- name: ReviewRequest :one
UPDATE requests r
SET status = $2,
    reviewed_by = $3,
    reviewed_at = NOW()
FROM items i
WHERE r.id = $1
  AND r.status = 'pending'
  AND r.item_id = i.id
  AND (
    $2 = 'denied'::request_status
    OR ($2 = 'approved'::request_status AND i.stock >= r.quantity)
  )
RETURNING r.id, r.user_id, r.group_id, r.item_id, r.quantity,
    r.status, r.reviewed_at, r.reviewed_by
`

type ReviewRequestParams struct {
	ID         uuid.UUID         `json:"id"`
	Status     NullRequestStatus `json:"status"`
	ReviewedBy *uuid.UUID        `json:"reviewed_by"`
}

type ReviewRequestRow struct {
	ID         uuid.UUID         `json:"id"`
	UserID     *uuid.UUID        `json:"user_id"`
	GroupID    *uuid.UUID        `json:"group_id"`
	ItemID     *uuid.UUID        `json:"item_id"`
	Quantity   int32             `json:"quantity"`
	Status     NullRequestStatus `json:"status"`
	ReviewedAt pgtype.Timestamp  `json:"reviewed_at"`
	ReviewedBy *uuid.UUID        `json:"reviewed_by"`
}

// this function updates the status of a request (approve or deny) and records who reviewed it and when
func (q *Queries) ReviewRequest(ctx context.Context, arg ReviewRequestParams) (ReviewRequestRow, error) {
	row := q.db.QueryRow(ctx, reviewRequest, arg.ID, arg.Status, arg.ReviewedBy)
	var i ReviewRequestRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.ItemID,
		&i.Quantity,
		&i.Status,
		&i.ReviewedAt,
		&i.ReviewedBy,
	)
	return i, err
}
