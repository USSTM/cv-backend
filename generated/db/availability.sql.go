// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: availability.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const checkAvailabilityConflict = `-- name: CheckAvailabilityConflict :one
SELECT EXISTS(
  SELECT 1 FROM user_availability
  WHERE user_id = $1
    AND time_slot_id = $2
    AND date = $3
) AS has_conflict
`

type CheckAvailabilityConflictParams struct {
	UserID     *uuid.UUID  `json:"user_id"`
	TimeSlotID *uuid.UUID  `json:"time_slot_id"`
	Date       pgtype.Date `json:"date"`
}

// Check if user already has availability for this slot/date
func (q *Queries) CheckAvailabilityConflict(ctx context.Context, arg CheckAvailabilityConflictParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkAvailabilityConflict, arg.UserID, arg.TimeSlotID, arg.Date)
	var has_conflict bool
	err := row.Scan(&has_conflict)
	return has_conflict, err
}

const checkAvailabilityInUse = `-- name: CheckAvailabilityInUse :one
SELECT EXISTS(
  SELECT 1 FROM booking
  WHERE availability_id = $1
    AND status IN ('pending', 'approved')
) AS in_use
`

// Check if availability is referenced by active bookings
func (q *Queries) CheckAvailabilityInUse(ctx context.Context, availabilityID *uuid.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, checkAvailabilityInUse, availabilityID)
	var in_use bool
	err := row.Scan(&in_use)
	return in_use, err
}

const createAvailability = `-- name: CreateAvailability :one
INSERT INTO user_availability (id, user_id, time_slot_id, date)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, time_slot_id, date
`

type CreateAvailabilityParams struct {
	ID         uuid.UUID   `json:"id"`
	UserID     *uuid.UUID  `json:"user_id"`
	TimeSlotID *uuid.UUID  `json:"time_slot_id"`
	Date       pgtype.Date `json:"date"`
}

func (q *Queries) CreateAvailability(ctx context.Context, arg CreateAvailabilityParams) (UserAvailability, error) {
	row := q.db.QueryRow(ctx, createAvailability,
		arg.ID,
		arg.UserID,
		arg.TimeSlotID,
		arg.Date,
	)
	var i UserAvailability
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TimeSlotID,
		&i.Date,
	)
	return i, err
}

const deleteAvailability = `-- name: DeleteAvailability :exec
DELETE FROM user_availability WHERE id = $1
`

func (q *Queries) DeleteAvailability(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAvailability, id)
	return err
}

const getAvailabilityByDate = `-- name: GetAvailabilityByDate :many
SELECT
  ua.id, ua.user_id, ua.time_slot_id, ua.date,
  u.email as user_email,
  ts.start_time,
  ts.end_time
FROM user_availability ua
JOIN users u ON ua.user_id = u.id
JOIN time_slots ts ON ua.time_slot_id = ts.id
WHERE ua.date = $1
ORDER BY ts.start_time, u.email
`

type GetAvailabilityByDateRow struct {
	ID         uuid.UUID   `json:"id"`
	UserID     *uuid.UUID  `json:"user_id"`
	TimeSlotID *uuid.UUID  `json:"time_slot_id"`
	Date       pgtype.Date `json:"date"`
	UserEmail  string      `json:"user_email"`
	StartTime  pgtype.Time `json:"start_time"`
	EndTime    pgtype.Time `json:"end_time"`
}

// Get all approvers available on a specific date
func (q *Queries) GetAvailabilityByDate(ctx context.Context, date pgtype.Date) ([]GetAvailabilityByDateRow, error) {
	rows, err := q.db.Query(ctx, getAvailabilityByDate, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAvailabilityByDateRow{}
	for rows.Next() {
		var i GetAvailabilityByDateRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TimeSlotID,
			&i.Date,
			&i.UserEmail,
			&i.StartTime,
			&i.EndTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailabilityByID = `-- name: GetAvailabilityByID :one
SELECT
  ua.id, ua.user_id, ua.time_slot_id, ua.date,
  u.email as user_email,
  ts.start_time,
  ts.end_time
FROM user_availability ua
JOIN users u ON ua.user_id = u.id
JOIN time_slots ts ON ua.time_slot_id = ts.id
WHERE ua.id = $1
`

type GetAvailabilityByIDRow struct {
	ID         uuid.UUID   `json:"id"`
	UserID     *uuid.UUID  `json:"user_id"`
	TimeSlotID *uuid.UUID  `json:"time_slot_id"`
	Date       pgtype.Date `json:"date"`
	UserEmail  string      `json:"user_email"`
	StartTime  pgtype.Time `json:"start_time"`
	EndTime    pgtype.Time `json:"end_time"`
}

func (q *Queries) GetAvailabilityByID(ctx context.Context, id uuid.UUID) (GetAvailabilityByIDRow, error) {
	row := q.db.QueryRow(ctx, getAvailabilityByID, id)
	var i GetAvailabilityByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TimeSlotID,
		&i.Date,
		&i.UserEmail,
		&i.StartTime,
		&i.EndTime,
	)
	return i, err
}

const getAvailabilityCountByUser = `-- name: GetAvailabilityCountByUser :one
SELECT COUNT(*) as count
FROM user_availability
WHERE user_id = $1
  AND date >= $2
  AND date <= $3
`

type GetAvailabilityCountByUserParams struct {
	UserID *uuid.UUID  `json:"user_id"`
	Date   pgtype.Date `json:"date"`
	Date_2 pgtype.Date `json:"date_2"`
}

// Get count of availability entries for a user in a date range
func (q *Queries) GetAvailabilityCountByUser(ctx context.Context, arg GetAvailabilityCountByUserParams) (int64, error) {
	row := q.db.QueryRow(ctx, getAvailabilityCountByUser, arg.UserID, arg.Date, arg.Date_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAvailableApproversForSlot = `-- name: GetAvailableApproversForSlot :many
SELECT DISTINCT u.id, u.email
FROM user_availability ua
JOIN users u ON ua.user_id = u.id
WHERE ua.date = $1
  AND ua.time_slot_id = $2
`

type GetAvailableApproversForSlotParams struct {
	Date       pgtype.Date `json:"date"`
	TimeSlotID *uuid.UUID  `json:"time_slot_id"`
}

type GetAvailableApproversForSlotRow struct {
	ID    uuid.UUID `json:"id"`
	Email string    `json:"email"`
}

// Find all approvers available for a specific date/time slot
func (q *Queries) GetAvailableApproversForSlot(ctx context.Context, arg GetAvailableApproversForSlotParams) ([]GetAvailableApproversForSlotRow, error) {
	rows, err := q.db.Query(ctx, getAvailableApproversForSlot, arg.Date, arg.TimeSlotID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAvailableApproversForSlotRow{}
	for rows.Next() {
		var i GetAvailableApproversForSlotRow
		if err := rows.Scan(&i.ID, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAvailability = `-- name: GetUserAvailability :many
SELECT
  ua.id, ua.user_id, ua.time_slot_id, ua.date,
  ts.start_time,
  ts.end_time
FROM user_availability ua
JOIN time_slots ts ON ua.time_slot_id = ts.id
WHERE ua.user_id = $1
  AND ($2::DATE IS NULL OR ua.date >= $2)
  AND ($3::DATE IS NULL OR ua.date <= $3)
ORDER BY ua.date, ts.start_time
`

type GetUserAvailabilityParams struct {
	UserID   *uuid.UUID  `json:"user_id"`
	FromDate pgtype.Date `json:"from_date"`
	ToDate   pgtype.Date `json:"to_date"`
}

type GetUserAvailabilityRow struct {
	ID         uuid.UUID   `json:"id"`
	UserID     *uuid.UUID  `json:"user_id"`
	TimeSlotID *uuid.UUID  `json:"time_slot_id"`
	Date       pgtype.Date `json:"date"`
	StartTime  pgtype.Time `json:"start_time"`
	EndTime    pgtype.Time `json:"end_time"`
}

// Get a specific user's availability schedule
func (q *Queries) GetUserAvailability(ctx context.Context, arg GetUserAvailabilityParams) ([]GetUserAvailabilityRow, error) {
	rows, err := q.db.Query(ctx, getUserAvailability, arg.UserID, arg.FromDate, arg.ToDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserAvailabilityRow{}
	for rows.Next() {
		var i GetUserAvailabilityRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TimeSlotID,
			&i.Date,
			&i.StartTime,
			&i.EndTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAvailability = `-- name: ListAvailability :many
SELECT
  ua.id, ua.user_id, ua.time_slot_id, ua.date,
  u.email as user_email,
  ts.start_time,
  ts.end_time
FROM user_availability ua
JOIN users u ON ua.user_id = u.id
JOIN time_slots ts ON ua.time_slot_id = ts.id
WHERE ($1::DATE IS NULL OR ua.date = $1)
  AND ($2::UUID IS NULL OR ua.user_id = $2)
ORDER BY ua.date, ts.start_time
`

type ListAvailabilityParams struct {
	FilterDate   pgtype.Date `json:"filter_date"`
	FilterUserID *uuid.UUID  `json:"filter_user_id"`
}

type ListAvailabilityRow struct {
	ID         uuid.UUID   `json:"id"`
	UserID     *uuid.UUID  `json:"user_id"`
	TimeSlotID *uuid.UUID  `json:"time_slot_id"`
	Date       pgtype.Date `json:"date"`
	UserEmail  string      `json:"user_email"`
	StartTime  pgtype.Time `json:"start_time"`
	EndTime    pgtype.Time `json:"end_time"`
}

func (q *Queries) ListAvailability(ctx context.Context, arg ListAvailabilityParams) ([]ListAvailabilityRow, error) {
	rows, err := q.db.Query(ctx, listAvailability, arg.FilterDate, arg.FilterUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAvailabilityRow{}
	for rows.Next() {
		var i ListAvailabilityRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TimeSlotID,
			&i.Date,
			&i.UserEmail,
			&i.StartTime,
			&i.EndTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
